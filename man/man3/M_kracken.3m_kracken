." Text automatically generated by txt2man
.TH "untitled" "" "April 14, 2023" "" "" " "
." -----------------------------------------------------------------
." * set default formatting
." disable hyphenation
.nh
." disable justification (adjust text to left margin only)
.ad l
." set smaller margin and spacing options
.ta T 0.2i
.nr IN 0.2i
." -----------------------------------------------------------------
.RS
[1][GPF Home Page]
.RE
.RE
.PP
KRACKEN(3F): The Fortran Command Line Argument Cracker
(Extended Version)
.PP
.nf
.fam C
   This version is dependent upon Fortran 2008 features and other GPF
   (General Purpose Fortran) modules. See the simpler [2]Fortran 2003 and
   FORTRAN 77 versions if you are looking for older stable versions that
   do not require other CLI (Command Line Interface) modules from the GPF
   collection.
     * [3]Abstract
     * [4]Example of typical use
     * [5]Routine Descriptions
     * [6]Using the interactive menu mode of prompting
     * [7]Usage notes
     * [8]Alternate parsing of the command line arguments

   To get a demonstration program and the source for the M_kracken module
   download the [9]source files for the module, other modules it is
   dependent on, and many example programs that call KRACKEN(3f).

.fam T
.fi
.SH NAME

M_kracken(3fm) - [ARGUMENTS:M_kracken] parse command line options of
Fortran programs using Unix-like syntax (LICENSE:PD)

.SH ABSTRACT

KRACKEN(3f) is a Fortran command line argument parser designed to
provide for easy entry of lists of negative numbers, strings, and
exponential numbers without generally requiring quotes on the command
line. It provides:
.RS
.IP \(bu 3
a standard Unix-like style for parsing arguments and keywords
.IP \(bu 3
a clear way to specify allowable keywords and default values
.IP \(bu 3
simple access to the parsed data from procedures
.IP \(bu 3
easy conversion from strings to numbers
.IP \(bu 3
easy conversion from strings to arrays
.IP \(bu 3
a simple menu-driven interactive mode for modifying parameters
.RE
.PP
You can call your command like this:
mycode \fB-r\fP 333.333 \fB-file\fP /home/testin \fB-l\fP \fB-i\fP 300
.PP
.nf
.fam C
   with very little code:

.fam T
.fi
Example Usage
.RE
.PP
program myprogram
.PP
.nf
.fam C
   use M_kracken
   character(255) filename
   logical lval
   !  define command arguments, default values and crack command line
   call kracken('cmd','-i 10 -r 10e3 -d 4.1123344d0 -l .false. -file input')
   !  get values
   call retrev('cmd_f',filename,iflen,ier) ! get -f FILENAME
   lval = lget('cmd_l')                    ! get -l present?
   rval = rget('cmd_r')                    ! get -r RVAL
   dval = dget('cmd_d')                    ! get -d DBLEVAL
   ival = iget('cmd_i')                    ! get -i IVAL
   !  all done parsing; do something with the values
   print *, "filename=",filename(:iflen)
   print *, " i=",ival, " r=",rval, " l=",lval, "d=",dval
.fam T
.fi
end program myprogram
.PP
.nf
.fam C
   See the documentation for the procedures for detailed descriptions.
   Each procedure description includes a working example program.

.fam T
.fi
The Routines
.PP
.nf
.fam C
     [10]kracken define command options and defaults and parse command
.fam T
.fi
line
.PP
.nf
.fam C
     [11]retrev get value for a keyword as a string

.fam T
.fi
The returned strings obtained by calls to RETREV(3f) can be converted
to numeric values using procedures from the M_strings(3fm) module such
as STRING_TO_VALUE(3F), which converts strings to a numeric value, and
SPLIT(3F), which can break a string into a list of words. But more
commonly, the following convenience routines are used \.\.\.
.RS
.PP
There are scalar convenience functions for getting simple values that
are used in most cases as an alternative to RETREV(3f) that convert the
values directly to common scalar types:
lval=[12]lget(VERB_ARGNAME) !gets a "logical" value.
rval=[13]rget(VERB_ARGNAME) !gets a "real" value.
dval=[14]dget(VERB_ARGNAME) !gets a "doubleprecision" value.
ival=[15]iget(VERB_ARGNAME) !gets a "integer" value
sval=[16]sget(VERB_ARGNAME) !gets a "character" value
.PP
There are also convenience routines for returning arrays of scalar
values that typically use allocatable arrays. Just add 's' to the end
of the scalar convenience functions.
lvals=[17]lgets(VERB_ARGNAME) !gets a "logical" array.
rvals=[18]rgets(VERB_ARGNAME) !gets a "real" array.
dvals=[19]dgets(VERB_ARGNAME) !gets a "doubleprecision" array.
ivals=[20]igets(VERB_ARGNAME) !gets a "integer" array
svals=[21]sgets(VERB_ARGNAME) !gets a "character" array
.RE
.PP
SPECIAL-PURPOSE PUBLIC ROUTINES:
.PP
.nf
.fam C
    Setting command prompts

.fam T
.fi
.RS
.TP
.B public :: setprompts
! define prompts for commands in interactive
mode
.PP
.nf
.fam C
    Only needed for parsing input files, not cracking command line arguments

.fam T
.fi
.TP
.B [22]dissect
! for user-defined commands: define defaults, then process user
input
.TP
.B [23]parse
! parse user command and store tokens into Language Dictionary
.TP
.B [24]store
! replace dictionary name's value (if allow=add add name if nece
ssary)
.TP
.B [25]show
! display dictionary contents for information
.PP
.nf
.fam C
    length of verbs and entries in Language dictionary

.fam T
.fi
NOTE: many parameters may be reduced in size so as to just accommodate
being used as a command line parser. In particular, some might want to
change:
.TP
.B logical,public
:: stop_command=.false. ! indication to return stop
_command as false in interactive mode
.TP
.B integer, parameter,public :: IPvalue=4096*16
! length of keyword value
.TP
.B integer, parameter,public :: IPverb=20
! length of verb
.TP
.B character(len=1),save,public
:: kracken_comment='#'
.TP
.B character(len=:),allocatable,public
:: leftover                 ! remaining
command(s) on line
.TP
.B integer,public,save
:: current_command_length=0 ! length of
options for current command
.RE
.PP
Interactive menu mode
.PP
.nf
.fam C
   The menu mode feature is in a state of flux and may change
   significantly \.\.\.

   All commands automatically have the parameter "-?". If it is present, a
   menu appears after any specified options have been applied that allows
   for changing parameters interactively.

   The default prompts are the keywords themselves and their current
   values. To set your own prompts call SETPROMPTS(3f):
   call setprompts(verb_name,options_and_prompts)

   where the special prompt string "#N#" means to not allow prompting for
   this parameter. For example:
     ! set prompts for interactive mode \.\.\.
     call setprompts('copy','                           &
     & -oo "#N#"                                        &
     & -i Enter input file name                         &
     & -o Enter output file name                        &
     & -version "#N#"                                   &
     & -help "#N#"                                      &
     & ')
     call kracken('copy','-i -o -version .false. -help .false')

   Then the command
      copy -?

   would only prompt for the -i and -o parameters.

   A description on how to use the menu mode can be generated by entering
   a question mark ("?") at the prompt once menu mode has been invoked.

.fam T
.fi
Usage Notes
.PP
.nf
.fam C
  the reserved -oo keyword

   Everything before any switch is always referred to as 'VERB_oo' in
   RETREV(3f). This same value can also be set later in the command line
   by using the reserved keyword -oo (or the alias --). Often, you can
   ignore it exists, but the -oo option is always there. Unlike other
   parameters a default value is ignored unless no parameters are
   specified on the command line. That is, in general do not set a default
   value for the -oo parameter. It should almost always be initially a
   blank string.

   Note that you can just put the calls to RETREV() or the convenience
   routines where you need the information in your program instead of
   parsing everything in a single routine. But parsing them and storing
   them into a COMMON or MODULE is more efficient if the routine doing the
   parsing is called many times.
  Sample showing -oo parameter and retrieving data in subroutines

     program demo_M_kracken
     use M_kracken, only : kracken
     implicit none
     real :: x, y
     ! define and crack command line arguments
     call kracken('cmd',' DEFAULT STRING -x 123 -y 456 ')
     call showstring()
     call showvalue()
     contains

     subroutine showstring()
     use M_kracken, only : sget
     character(len=:),allocatable :: string
     ! get value of string before any switch
     string=trim(sget('cmd_oo'))
     write(*,*)'string is ',string
     end subroutine showstring

     subroutine showvalue()
     use M_kracken, only : rget
     ! show values for -x and -y parameters
     x=rget('cmd_x')
     y=rget('cmd_y')
     write(*,*)' X and Y are ',x,y
     end subroutine showvalue

     end program demo_M_kracken

      xxx
       string is DEFAULT STRING
        X and Y are    123.000000       456.000000

      xxx -x 987.653992
       string is
        X and Y are    987.653992       456.000000

      xxx -oo BBBB -oo CCCC
       string is BBBB CCCC
        X and Y are    123.000000       456.000000

      xxx AAAA BBBB -oo CCCC
       string is AAAA BBBB CCCC
        X and Y are    123.000000       456.000000

   You may note that the parsing rules are not identical to Unix, although
   very similar.

.fam T
.fi
SYNTAX:
.RS
.TP
.B verb[-oo|--] value for kw_oo
[-kw1 value_for_kw1] [-kw2 value_for_kw2] [-kw3 va
lue_for_kw3] \.\.\.
where
"kw" stands for a keyword name
.RS
.IP \(bu 3
Quotes are rarely needed. A keyword is assumed whenever "
\fB-[A-Za-Z\fP]" (space followed by dash followed by letter) is
encountered. So
cmd \fB-title\fP This is my title \fB-value\fP 10.3e2
.RS
.PP
would produce a value of "This is my title" for dictionary value
"cmd_title". This does mean if your value contains " \fB-letter\fP" you
must quote your command such that the program sees the string
surrounded with double-quotes. Depending on the shell you are using
this can be awkward. For example, in the bash shell you might use
cmd \fB-title\fP '"\fB-A\fP is a bad title to need"'
cmd \fB-title\fP /"\fB-A\fP is a bad title to need/"
.RE
.IP \(bu 3
The keyword \fB-oo\fP is implied after the verb.
.IP \(bu 3
There is no way to terminate a keyword value except by starting a
new keyword. This means when you use shell globbing you often want
filenames to be the first parameter (and dictionary "cmd_oo" will
hold the filenames):
cmd * \fB-value\fP 10.3e2
.RS
.PP
Many (but not all) Unix commands have such values allowed wherever
another value is not allowed (Surprised? "ls \fB-r\fP * \fB-l\fP" works as well
as "ls \fB-r\fP \fB-l\fP *" .). This is why quoting and specification of which
keywords require values and which do not is usually required on
Unix commands. Alternatively, just ignore the \fB-oo\fP field and always
require keywords for all values.
.RE
.IP \(bu 3
You cannot combine keywords (\fB-ir\fP is not equivalent to \fB-i\fP \fB-r\fP, which
is sometimes allowed on Unix commands).
.IP \(bu 3
Although this is rarely needed in practice, You may find the way to
include a literal double-quote character (") as part of an input
value is the most unlike Unix -- Double the double-quote. Again,
shells often expand double-quotes, so in the bash(1) shell you
might have to enter
.RS
.TP
.B cmd
\fB-string\fP \\"\\"
.RE
.PP
to give the "cmd_string" dictionary value the simple value '"'.
.IP \(bu 3
\fB--KEYWORD\fP is equivalent to \fB-KEYWORD\fP; primarily so that the
\fB--version\fP and \fB--help\fP options are easily supported.
.IP \(bu 3
If a keyword is specified multiple times the values are
concatenated into a single value with a space delimiter between the
values. That is,
cmd \fB-D\fP 10 \fB-D\fP 20 \fB-D\fP 30
.PP
.nf
.fam C
       would set the dictionary variable "cmd_D" to '10 20 30'.
.fam T
.fi
.IP \(bu 3
All commands automatically have the -? keyword, which evokes
interactive menu mode.
.RE
.PP
Alternate command line input syntax
.PP
.nf
.fam C
   If you actually prefer quoting your arguments and having your unnamed
   variables at the end of your command and support for the "--" option
   supported by some GNU and Unix commands you can set the command line
   parsing option "style='args'". This will not change how you specify the
   parameters to the kracken(3f) command except possibly for Boolean
   switches, but allows for entering commands in a manner more like the C
   routine getopts(3c). If you turn the mode on the "-oo" parameter is
   ignored unless you specifically assign it a value by name; the values
   need quoted if they contain spaces and the option "--" specifies that
   the rest of the command line is composed of unnamed strings. The
   unnamed values will go into the CHARACTER array "unnamed". The way the
   command line input is parsed is the same as in the M_args(3f) module.
   That means instead of entering:

     program show_standard
     use M_kracken, only : kracken, sgets, rget, sget, lget
     implicit none
     character(len=:),allocatable :: files(:)
     character(len=:),allocatable :: title
     real :: x,y
     integer :: i
     ! define and crack command line arguments
     call kracken('cmd',' --title this is my title -x 123 -y 456 --help .false.'
.fam T
.fi
)
.PP
.nf
.fam C
     title=sget('cmd_title')
     x=rget('cmd_x')
     y=rget('cmd_y')
     write(*,*)'help=',lget('cmd_help')
     write(*,*)' title is ',title
     write(*,*)' x and y are ',x,y
     ! get value of string before any switch
     files=sgets('cmd_oo')
     if(size(files).gt.0)then
        do i=1,size(files)
           write(*,*)i,files(i)
        enddo
     endif
     end program show_standard

.fam T
.fi
Add "style='args'" to the kracken call and "unnamed" from the
M_kracken(3fm) module, and the unnamed values will be in the string
array "unnamed" instead of obtained from something like
"sgets('cmd_oo').
.RS
.PP
With "style='args' other differences are in how you specify your
command prototype. You MUST use the string ".false." for any boolean
switch variable default value; and basically the values ".true." and
".false." are reserved, regardless of case. This is normally how you
specify booleans anyway; but in the default style you can set your
default to ".true." or use other values for ".false." like "F" or
".F.".
.PP
The way the arguments will then be read upon input are the same as
described in the M_args(3fm) module.
.PP
.nf
.fam C
     program show_alternate
     use M_kracken, only : kracken, sget, rget, lget
     USE M_KRACKEN, ONLY : UNNAMED
     implicit none
     character(len=:),allocatable :: title
     real :: x,y
     integer :: i
     ! define and crack command line arguments
     !
     !
     call kracken('cmd',' --title this is my title &
      & -x 123 -y 456 --help .false.',style='args')
     title=sget('cmd_title')
     x=rget('cmd_x')
     y=rget('cmd_y')
     write(*,*)'help=',lget('cmd_help')
     write(*,*)' title is ',title
     write(*,*)' x and y are ',x,y

     IF(SIZE(UNNAMED).GT.0)THEN
        DO I=1,SIZE(UNNAMED)
           WRITE(*,*)I,UNNAMED(I)
.fam T
.fi
.SS        ENDDO
.SS     ENDIF
end program show_alternate
Sample usage:
.PP
.nf
.fam C
    # first program uses default M_kracken parsing

       cmd *.f90 -x 100 --title A new title -y 200

    # or

       cmd -x 100 --title A new title -y 200 -oo *.f90

    # second program uses alternate command-line parsing.
    # the unnamed values go into the string array
    # UNNAMED but can appear anywhere on the command.
    # multi-word values require being quoted.

    cmd -x 100 -y 200 --title 'A new title' *.f90

     Contributors:
     * John S. Urban -- Author (last change: Oct. 2019)
     * Felix Becker -- Enhancements to reduce limitations on parameter
       lengths (2013-05-28)
     * Walid Keyrouz -- Upgrades to bring code into conformance with
       recommended practices (2013-12-06)

.fam T
.fi
\[char46]fi</xmp </div>
</div>
</div>
</div>
</body>
</html>
.RE
.PP
References
.RS
.IP 1. 4
http://www.urbanjost.altervista.org/LIBRARY/libGPF/GPF.html
.IP 2. 4
file:///home/urbanjs/venus/V600/github/arguments/src2015/krackenhelp.html
.IP 3. 4
file:///home/urbanjs/venus/V600/github/ARGS/M_kracken/docs/M_kracken.3m_kracken.html#ABSTRACT
.IP 4. 4
file:///home/urbanjs/venus/V600/github/ARGS/M_kracken/docs/M_kracken.3m_kracken.html#EX1
.IP 5. 4
file:///home/urbanjs/venus/V600/github/ARGS/M_kracken/docs/M_kracken.3m_kracken.html#DESCRIPTION
.IP 6. 4
file:///home/urbanjs/venus/V600/github/ARGS/M_kracken/docs/M_kracken.3m_kracken.html#MENU
.IP 7. 4
file:///home/urbanjs/venus/V600/github/ARGS/M_kracken/docs/M_kracken.3m_kracken.html#USAGE
.IP 8. 4
file:///home/urbanjs/venus/V600/github/ARGS/M_kracken/docs/M_kracken.3m_kracken.html#ARGS
.IP 9. 4
file:///home/urbanjs/venus/V600/github/ARGS/M_kracken/docs/download.html
.RE
.IP 10. 4
file:///home/urbanjs/venus/V600/github/ARGS/M_kracken/docs/kracken.3.html
.RS
.IP 11. 4
file:///home/urbanjs/venus/V600/github/ARGS/M_kracken/docs/retrev.3.html
.IP 12. 4
file:///home/urbanjs/venus/V600/github/ARGS/M_kracken/docs/lget.3.html
.IP 13. 4
file:///home/urbanjs/venus/V600/github/ARGS/M_kracken/docs/rget.3.html
.IP 14. 4
file:///home/urbanjs/venus/V600/github/ARGS/M_kracken/docs/dget.3.html
.IP 15. 4
file:///home/urbanjs/venus/V600/github/ARGS/M_kracken/docs/iget.3.html
.IP 16. 4
file:///home/urbanjs/venus/V600/github/ARGS/M_kracken/docs/sget.3.html
.IP 17. 4
file:///home/urbanjs/venus/V600/github/ARGS/M_kracken/docs/lgets.3.html
.IP 18. 4
file:///home/urbanjs/venus/V600/github/ARGS/M_kracken/docs/rgets.3.html
.IP 19. 4
file:///home/urbanjs/venus/V600/github/ARGS/M_kracken/docs/dgets.3.html
.IP 20. 4
file:///home/urbanjs/venus/V600/github/ARGS/M_kracken/docs/igets.3.html
.IP 21. 4
file:///home/urbanjs/venus/V600/github/ARGS/M_kracken/docs/sgets.3.html
.IP 22. 4
file:///home/urbanjs/venus/V600/github/ARGS/M_kracken/docs/dissect.3.html
.IP 23. 4
file:///home/urbanjs/venus/V600/github/ARGS/M_kracken/docs/parse.3.html
.IP 24. 4
file:///home/urbanjs/venus/V600/github/ARGS/M_kracken/docs/store.3.html
.IP 25. 4
file:///home/urbanjs/venus/V600/github/ARGS/M_kracken/docs/show.3.html
