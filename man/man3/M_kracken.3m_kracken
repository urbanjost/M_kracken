." Text automatically generated by txt2man
.TH "untitled" "" "March 28, 2021" "" "" " "
." -----------------------------------------------------------------
." * set default formatting
." disable hyphenation
.nh
." disable justification (adjust text to left margin only)
.ad l
." -----------------------------------------------------------------
.RS
[GPF Home Page]
.PP
\fBKRACKEN\fP(3F): The Fortran Command Line Argument Cracker
(Extended Version)
.PP
This version is dependent upon Fortran 2008 features and other GPF (General
Purpose Fortran) modules. See the simpler Fortran 2003 and FORTRAN 77 versions
if you are looking for older stable versions that do not require other CLI
(Command Line Interface) modules from the GPF collection.
.RS
.IP \(bu 3
Abstract
.IP \(bu 3
Example of typical use
.IP \(bu 3
Routine Descriptions
.IP \(bu 3
Using the interactive menu mode of prompting
.IP \(bu 3
Usage notes
.IP \(bu 3
Alternate parsing of the command line arguments
.RE
.PP
To get a demonstration program and the source for the M_kracken module download
the source files for the module, other modules it is dependent on, and many
example programs that call \fBKRACKEN\fP(3f).
.SH NAME

\fBM_kracken\fP(3fm) - [ARGUMENTS:M_kracken] parse command line options of Fortran
programs using Unix-like syntax (LICENSE:PD)

.SH ABSTRACT

\fBKRACKEN\fP(3f) is a Fortran command line argument parser designed to provide for
easy entry of lists of negative numbers, strings, and exponential numbers
without generally requiring quotes on the command line. It provides:
.RS
.IP \(bu 3
a standard Unix-like style for parsing arguments and keywords
.IP \(bu 3
a clear way to specify allowable keywords and default values
.IP \(bu 3
simple access to the parsed data from procedures
.IP \(bu 3
easy conversion from strings to numbers
.IP \(bu 3
easy conversion from strings to arrays
.IP \(bu 3
a simple menu-driven interactive mode for modifying parameters
.RE
.PP
You can call your command like this:
.PP
.nf
.fam C
 mycode -r 333.333 -file /home/testin -l -i 300

.fam T
.fi
with very little code:
.PP
Example Usage
.PP
program myprogram
.PP
.nf
.fam C
   use M_kracken
   character(255) filename
   logical lval
   !  define command arguments, default values and crack command line
   call kracken('cmd','-i 10 -r 10e3 -d 4.1123344d0 -l .false. -file input')
   !  get values
   call retrev('cmd_f',filename,iflen,ier) ! get -f FILENAME
   lval = lget('cmd_l')                    ! get -l present?
   rval = rget('cmd_r')                    ! get -r RVAL
   dval = dget('cmd_d')                    ! get -d DBLEVAL
   ival = iget('cmd_i')                    ! get -i IVAL
   !  all done parsing; do something with the values
   print *, "filename=",filename(:iflen)
   print *, " i=",ival, " r=",rval, " l=",lval, "d=",dval
.fam T
.fi
end program myprogram
.PP
See the documentation for the procedures for detailed descriptions. Each
procedure description includes a working example program.
.PP
The Routines
.PP
kracken define command options and defaults and parse command line
retrev get value for a keyword as a string
.PP
The returned strings obtained by calls to \fBRETREV\fP(3f) can be converted to
numeric values using procedures from the \fBM_strings\fP(3fm) module such as
\fBSTRING_TO_VALUE\fP(3F), which converts strings to a numeric value, and \fBSPLIT\fP(3F),
which can break a string into a list of words. But more commonly, the following
convenience routines are used \.\.\.
.PP
There are scalar convenience functions for getting simple values that are used
in most cases as an alternative to \fBRETREV\fP(3f) that convert the values directly
to common scalar types:
.PP
.nf
.fam C
      lval=lget(VERB_ARGNAME) !gets a "logical" value.
      rval=rget(VERB_ARGNAME) !gets a "real" value.
      dval=dget(VERB_ARGNAME) !gets a "doubleprecision" value.
      ival=iget(VERB_ARGNAME) !gets a "integer" value
      sval=sget(VERB_ARGNAME) !gets a "character" value

.fam T
.fi
There are also convenience routines for returning arrays of scalar values that
typically use allocatable arrays. Just add 's' to the end of the scalar
convenience functions.
.PP
.nf
.fam C
      lvals=lgets(VERB_ARGNAME) !gets a "logical" array.
      rvals=rgets(VERB_ARGNAME) !gets a "real" array.
      dvals=dgets(VERB_ARGNAME) !gets a "doubleprecision" array.
      ivals=igets(VERB_ARGNAME) !gets a "integer" array
      svals=sgets(VERB_ARGNAME) !gets a "character" array

.fam T
.fi
SPECIAL-PURPOSE PUBLIC ROUTINES:
.PP
Setting command prompts
.PP
.nf
.fam C
   public :: setprompts             ! define prompts for commands in interactive mode

.fam T
.fi
Only needed for parsing input files, not cracking command line arguments
.PP
.nf
.fam C
   dissect  ! for user-defined commands: define defaults, then process user input
   parse    ! parse user command and store tokens into Language Dictionary
   store    ! replace dictionary name's value (if allow=add add name if necessary)
   show     ! display dictionary contents for information

.fam T
.fi
length of verbs and entries in Language dictionary
.PP
NOTE: many parameters may be reduced in size so as to just accommodate being
used as a command line parser. In particular, some might want to change:
.PP
.nf
.fam C
   logical,public            :: stop_command=.false. ! indication to return stop_command as false in interactive mode
   integer, parameter,public :: IPvalue=4096*16      ! length of keyword value
   integer, parameter,public :: IPverb=20            ! length of verb
   character(len=1),save,public         :: kracken_comment='#'
   character(len=:),allocatable,public  :: leftover                 ! remaining command(s) on line
   integer,public,save                  :: current_command_length=0 ! length of options for current command

.fam T
.fi
Interactive menu mode
.PP
The menu mode feature is in a state of flux and may change significantly \.\.\.
.PP
All commands automatically have the parameter "-?". If it is present, a menu
appears after any specified options have been applied that allows for changing
parameters interactively.
.PP
The default prompts are the keywords themselves and their current values. To
set your own prompts call \fBSETPROMPTS\fP(3f):
.PP
.nf
.fam C
   call setprompts(verb_name,options_and_prompts)

.fam T
.fi
where the special prompt string "#N#" means to not allow prompting for this
parameter. For example:
.PP
.nf
.fam C
     ! set prompts for interactive mode \.\.\.
     call setprompts('copy','                           &
     & -oo "#N#"                                        &
     & -i Enter input file name                         &
     & -o Enter output file name                        &
     & -version "#N#"                                   &
     & -help "#N#"                                      &
     & ')
     call kracken('copy','-i -o -version .false. -help .false')

.fam T
.fi
Then the command
.PP
.nf
.fam C
      copy -?


.fam T
.fi
would only prompt for the \fB-i\fP and \fB-o\fP parameters.
.PP
A description on how to use the menu mode can be generated by entering a
question mark ("?") at the prompt once menu mode has been invoked.
.PP
Usage Notes
.PP
the reserved \fB-oo\fP keyword
.PP
Everything before any switch is always referred to as 'VERB_oo' in \fBRETREV\fP(3f).
This same value can also be set later in the command line by using the reserved
keyword \fB-oo\fP (or the alias --). Often, you can ignore it exists, but the \fB-oo\fP
option is always there. Unlike other parameters a default value is ignored
unless no parameters are specified on the command line. That is, in general do
not set a default value for the \fB-oo\fP parameter. It should almost always be
initially a blank string.
.PP
Note that you can just put the calls to \fBRETREV\fP() or the convenience routines
where you need the information in your program instead of parsing everything in
a single routine. But parsing them and storing them into a COMMON or MODULE is
more efficient if the routine doing the parsing is called many times.
.PP
.nf
.fam C
  Sample showing -oo parameter and retrieving data in subroutines

.nf
.fam C
     program demo_M_kracken
     use M_kracken, only : kracken
     ! define and crack command line arguments
     call kracken('cmd',' DEFAULT STRING -x 123 -y 456 ')
     call showstring()
     call showvalue()
     contains

     subroutine showstring()
     use M_kracken, only : sget
     character(len=:),allocatable :: string
     ! get value of string before any switch
     string=trim(sget('cmd_oo'))
     write(*,*)'string is ',string
     end subroutine showstring

     subroutine showvalue()
     use M_kracken, only : rget
     ! show values for -x and -y parameters
     x=rget('cmd_x')
     y=rget('cmd_y')
     write(*,*)' X and Y are ',x,y
     end subroutine showvalue

     end program demo_M_kracken

.nf
.fam C
      xxx
       string is DEFAULT STRING
        X and Y are    123.000000       456.000000

      xxx -x 987.653992
       string is
        X and Y are    987.653992       456.000000

      xxx -oo BBBB -oo CCCC
       string is BBBB CCCC
        X and Y are    123.000000       456.000000

      xxx AAAA BBBB -oo CCCC
       string is AAAA BBBB CCCC
        X and Y are    123.000000       456.000000

.fam T
.fi
You may note that the parsing rules are not identical to Unix, although very
similar.
.PP
SYNTAX:
.TP
.B verb[-oo|--] value for kw_oo
[-kw1 value_for_kw1] [-kw2 value_for_kw2] [-kw3 value_for_kw3] \.\.\.
where
"kw" stands for a keyword name
.RS
.IP \(bu 3
Quotes are rarely needed. A keyword is assumed whenever " \fB-[A-Za-Z\fP]" (space
followed by dash followed by letter) is encountered. So
.PP
.nf
.fam C
            cmd -title This is my title -value 10.3e2


.fam T
.fi
.RS
would produce a value of "This is my title" for dictionary value
"cmd_title". This does mean if your value contains " \fB-letter\fP" you must
quote your command such that the program sees the string surrounded with
double-quotes. Depending on the shell you are using this can be awkward.
For example, in the bash shell you might use
.PP
.nf
.fam C
            cmd -title '"-A is a bad title to need"'
            cmd -title /"-A is a bad title to need/"


.fam T
.fi
.RE
.IP \(bu 3
The keyword \fB-oo\fP is implied after the verb.
.IP \(bu 3
There is no way to terminate a keyword value except by starting a new
keyword. This means when you use shell globbing you often want filenames to
be the first parameter (and dictionary "cmd_oo" will hold the filenames):
.PP
.nf
.fam C
            cmd * -value 10.3e2


.fam T
.fi
.RS
Many (but not all) Unix commands have such values allowed wherever another
value is not allowed (Surprised? "ls \fB-r\fP * \fB-l\fP" works as well as "ls \fB-r\fP \fB-l\fP *"
.). This is why quoting and specification of which keywords require values
and which do not is usually required on Unix commands. Alternatively, just
ignore the \fB-oo\fP field and always require keywords for all values.
.RE
.IP \(bu 3
You cannot combine keywords (\fB-ir\fP is not equivalent to \fB-i\fP \fB-r\fP, which is
sometimes allowed on Unix commands).
.IP \(bu 3
Although this is rarely needed in practice, You may find the way to include
a literal double-quote character (") as part of an input value is the most
unlike Unix -- Double the double-quote. Again, shells often expand
double-quotes, so in the \fBbash\fP(1) shell you might have to enter
.PP
.nf
.fam C
             cmd  -string \\"\\"


.fam T
.fi
.RS
to give the "cmd_string" dictionary value the simple value '"'.
.RE
.IP \(bu 3
\fB--KEYWORD\fP is equivalent to \fB-KEYWORD\fP; primarily so that the \fB--version\fP and
\fB--help\fP options are easily supported.
.IP \(bu 3
If a keyword is specified multiple times the values are concatenated into a
single value with a space delimiter between the values. That is,
.PP
.nf
.fam C
          cmd -D 10 -D 20 -D 30


.fam T
.fi
.RS
would set the dictionary variable "cmd_D" to '10 20 30'.
.RE
.IP \(bu 3
All commands automatically have the -? keyword, which evokes interactive
menu mode.
.RE
.PP
Alternate command line input syntax
.PP
If you actually prefer quoting your arguments and having your unnamed variables
at the end of your command and support for the "--" option supported by some
GNU and Unix commands you can set the command line parsing option "style=
'args'". This will not change how you specify the parameters to the \fBkracken\fP(3f)
command except possibly for Boolean switches, but allows for entering commands
in a manner more like the C routine \fBgetopts\fP(3c). If you turn the mode on the
"\fB-oo\fP" parameter is ignored unless you specifically assign it a value by name;
the values need quoted if they contain spaces and the option "--" specifies
that the rest of the command line is composed of unnamed strings. The unnamed
values will go into the CHARACTER array "unnamed". The way the command line
input is parsed is the same as in the \fBM_args\fP(3f) module. That means instead of
entering:
.PP
.nf
.fam C
     program show_standard
     use M_kracken, only : kracken, sgets, rget, sget, lget
     implicit none
     character(len=:),allocatable :: files(:)
     character(len=:),allocatable :: title
     real :: x,y
     integer :: i
     ! define and crack command line arguments
     call kracken('cmd',' --title this is my title -x 123 -y 456 --help .false.')

     title=sget('cmd_title')
     x=rget('cmd_x')
     y=rget('cmd_y')
     write(*,*)'help=',lget('cmd_help')
     write(*,*)' title is ',title
     write(*,*)' x and y are ',x,y
     ! get value of string before any switch
     files=sgets('cmd_oo')
     if(size(files).gt.0)then
        do i=1,size(files)
           write(*,*)i,files(i)
        enddo
     endif
     end program show_standard

.fam T
.fi
Add "style='args'" to the kracken call and "unnamed" from the \fBM_kracken\fP(3fm)
module, and the unnamed values will be in the string array "unnamed" instead of
obtained from something like "sgets('cmd_oo').
.PP
With "style='args' other differences are in how you specify your command
prototype. You MUST use the string ".false." for any boolean switch variable
default value; and basically the values ".true." and ".false." are reserved,
regardless of case. This is normally how you specify booleans anyway; but in
the default style you can set your default to ".true." or use other values for
".false." like "F" or ".F.".
.PP
The way the arguments will then be read upon input are the same as described in
the \fBM_args\fP(3fm) module.
.PP
.nf
.fam C
     program show_alternate
     use M_kracken, only : kracken, sget, rget, lget
     USE M_KRACKEN, ONLY : UNNAMED
     implicit none
     character(len=:),allocatable :: title
     real :: x,y
     integer :: i
     ! define and crack command line arguments
     !
     !
     call kracken('cmd',' --title this is my title &
      & -x 123 -y 456 --help .false.',style='args')
     title=sget('cmd_title')
     x=rget('cmd_x')
     y=rget('cmd_y')
     write(*,*)'help=',lget('cmd_help')
     write(*,*)' title is ',title
     write(*,*)' x and y are ',x,y

     IF(SIZE(UNNAMED).GT.0)THEN
        DO I=1,SIZE(UNNAMED)
           WRITE(*,*)I,UNNAMED(I)
.fam T
.fi
.SS        ENDDO
.SS     ENDIF
end program show_alternate
.RE
.PP
Sample usage:
.PP
.nf
.fam C
    # first program uses default M_kracken parsing

.nf
.fam C
       cmd *.f90 -x 100 --title A new title -y 200

.fam T
.fi
.RS
# or
.PP
.nf
.fam C
       cmd -x 100 --title A new title -y 200 -oo *.f90

.fam T
.fi
# second program uses alternate command-line parsing.
# the unnamed values go into the string array
# UNNAMED but can appear anywhere on the command.
# multi-word values require being quoted.
.PP
cmd \fB-x\fP 100 \fB-y\fP 200 \fB--title\fP 'A new title' *.f90
.PP
Contributors:
.RS
.IP \(bu 3
John S. Urban -- Author (last change: Oct. 2019)
.IP \(bu 3
Felix Becker -- Enhancements to reduce limitations on parameter lengths
(2013-05-28)
.IP \(bu 3
Walid Keyrouz -- Upgrades to bring code into conformance with
recommended practices (2013-12-06)
.RE
.RE
.PP
.fi
